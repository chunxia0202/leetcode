### ==岛屿问题==

1----最简单的只让你求出这个**水域上面有几个岛屿**，岛屿是连续的一大块，但凡是连接在一起的，那就是一块而已，所以这里要进行合并，若有一个岛屿，那就将他的相邻的1都改为0，说明这些都是同一个岛屿

- 算法：递归，迭代（使用队列存放相邻的节点，确保所有的相邻的周围也能改为0），并查集（unionfind)

2-----要求**能找出不同的岛屿**，首先是一块岛屿的话，先要将其相邻的1改为0，然后改的时候记录下路径，根据上下左右的方向去存路径，再有一个hashset来存储路径，如果这个路径之前出现过，那就是相同的岛屿，结果不+1；

- 算法：递归

3----要求**能算出岛屿的周长**，因为岛屿的周长就是每个边界岛屿的边长，也就是说当前值为1时，首先能说明他不是水域，并且判断这个岛屿的其他方向，比如，他的上方是水域，那么上方的边长就可以作为周长的一条边，那么结果+1，如果上方的结果还是1，说明还是岛屿，那就这个边长不能用，因为他在岛屿内部的，接下来判断其他方向的岛屿边长，计算出结果

- 算法：迭代

4----**计算岛屿的最大面积**：使用迭代，如果遍历到值为1的时候，说明面积已经有1了，那么需要遍历他的最多有多少个相邻的岛屿，

​       有的话就面积加1，注意遍历过的地方就不能再遍历了，所以使用二维布尔数组来维护，并且这里要将他的所有相邻节点都找出来

​       所以需要使用队列来存储所有的相邻节点。

### ==链表问题==

1-----最简单的**反转链表**，就是将链表内的指针方向交换一下，可以使用递归或者迭代

​         递归算法的时候要记住res.next=dfs(head.next)，一定要是head.next，否则会栈溢出异常的，要从最末尾开始转变方向，所以是 

​          head.next，要不断的往后遍历，找到最末尾，改变玩指针方向之后再返回。

2-----实现**反转left-right内的节点**，其他保持不变，返回反转后的链表

- 解法：分为三部分，左面 不用反转的，中间正在反转的，右边剩余的，先将中间的划分出来，然后用head,tail来维护，head,tail使用反转函数反转后，head为交换后的头结点，pre.next=head,  tail.next=next;可以解决

3-----与2类似的题目是**反转k个一组的链表**，分为以及反转过的，正在反转的，还未反转的，也是需要一个反转函数，当然如果规定长度没有到达k的链表也要返回，只需要改一个地方就可。

4-----**排序链表**，使用归并算法，分别sublen维护现在需要两个长度为sublen的链表进行和排序并合并，pre.next=merge,再继续将链表剩下的进行排序，当前子链表 长度为sublen排序完之后，再排序子链表为sublen*2的链表。

- **自底向上**：就是从长度为1的两个子链表开始排序，sublen就是自底向上，不需要递归，所以空间为o(1)
- **自顶向下**：普通的归并方法，将链表先拆分为两个子链表，再将各个子链表拆分排序，直到最后一个节点时，链表不用排序了，合并
- **快排**：使用快排的思想，以第一个节点为哨兵，遍历第二个开始的节点，如果比当前节点小，那就放在小small链表中，如果比当前的大，那就放在large的链表中，然后再单独对smart和large链表排序，需要递归，所以空间复杂度为o(logn)

5-----**删除链表的重复值**

- 删除链表中重复出现的节点，使其每个节点只出现一次，例 3 3 2 2 1 返回3 2 1

  遍历链表，若发现当前的节点和后面的节点值相等，那就head.next=head.next.next;跳过相等的那个值

- 删除链表重复的所有节点，只保留出现一次的节点：例如1 1 1 2 3返回2 3

  由于只能保留出现一次的节点，那么出现很多次的节点需要全部删除掉，使用递归

6----**链表的奇偶位排列**：将奇数位的值放在奇数链表中，偶数位的值放在偶数链表中，最后将偶数链表的末尾赋值为null，否则会有环形

​       的风险

### ==动态规划==

**子序列问题**：

​      一个串的子串是指该串的一个连续的局部。如果不要求连续，则可称为它的子序列。 比如对串： "abcdefg" 而言，"ab","abd","bdef" 等都是它的子序列。

​     特别地，一个串本身，以及空串也是它的子序列。

​     字符串翻转的API：StringBuffer res=new StringBuffer(），res.append("abc")  res.reverse().toString();得到的结果为cba

​     或者将字符串转换为数组，利用StringBuffer将数组从末尾开始拼接，实现反转。

1-----**最长子序列问题**：子序列是不需要连续的一段，而子串是需要连续的，最长子序列问题的解决使用的是动态规划，使用动态规划能找到最大的子序列长度是多少，但是找不到具体的子序列，需要我们自己找

​         最长子序列问题：例如"1A2C3D4B56","B1D23A456A"两个字符串的最长子序列，分别判断当前i与j位置的字符是否相等，相等前i与    

​         前j位置的最长子序列为dp[i-1] [j-1]+1，如果不等，那就为dp[i-1] [j] dp[i] [j-1]的最大值；接下来要找出具体的子序列，用   

​         StringBuffer来存储结果，先从最后面开始判断，当最后一个字符相等时，那个就是子序列，再将指针往左移动，如果i与j的位置

​         不相等的时候，那就判断前i-1位置与前j位置的子序列与i--j-1位置的子序列哪个大，哪个大哪个左移

2------**最长上升子序列**：例如1 2 3 4 3 5最长上升子序列为1 2 3 4 5,注意子序列是可以不连续的，而子串是需要连续的。涉及到子序列

​         子串的问题都可以使用动态规划的方法做，遍历每个位置i，然后从0开始遍历到i，如果发现j的值比i的小，那就可以作为一个子序列

​          dp[i]=Math.max(dp[i],dp[j]+1);

3------**最长公共子串**：例如"1AB2345CD","12345EF"，最长公共子串为2 3 4 5，注意子串是需要连续的，所以当i与j相等，那么

​          dp[i] [j]=dp[i-1] [j-1]+1,不相等的话dp[i] [j]=dp[i-1] [j],dp[i] [j-1]的最大值;

4------**不同的子序列**（lc115)：s = "rabbbit", t = "rabbit"   判断s中存在多少个子序列和t相同；如果t为空，那么只有一个；

5------**将数字翻译为字符串**：例如12可以翻译为ab或者l，也就是可以整合编码或者单独编码；1->'a',26->'z';

​          当出现00与30的情况不能将数字翻译为字符串，当10的时候只能整和翻译，不能单独翻译，因为0不能翻译成有效的字符串

​          当当前位置的值为0，并且前一个值为0或者3那么返回0；不能翻译成字符串

​          当当前位置的值不为0，并且与左边的组合>10并且<26，那么可以整合或者单独翻译dp[i]=dp[i-1]+dp[i-2]；i-1是单独翻译，i-2是整合

​          当相邻的两个值不在10-26范围内，并且当前值不是0，那就只能单独翻译。

### ==递归问题==

1-----**子集问题**，使用回溯，[1，2，3]的子集大概有哪些？

​         []，[1]，[2]，[3]，[1，2]，[1，3]，[1，2，3]那么根据他的长度来判断，当path的容量是当前子集的长度时，将当前的path加到结

​        果集里面。这里要注意解决[1，2]，[2，1]的重复问题，那么可以规定i的下一次遍历的起始位置只能是i+1,避免了2的下一次还能走到

​        1这个位置，这里没有涉及到顺序问题，所以不用在前面对数组进行排序。

2-----**全排列问题**：利用[1，2，3]的全排列，这是没有重复元素下的全排列，可以直接递归，使用used数组来维护下一个数值是否已经

​         存在于path中，存在的话这个值就不用了。

3-----**全排列有重复值问题**：例如[1 1 3]那么全排列结果不能出现两次[1 1 3]，那我们需要判断nums[i]==nums[i-1] && used[i-1]为false

​        的时候，直接跳过第二个重复的起始位置。注意为了防止[3 0 3]这种情况出现的时候，只有这种判断情况是不够的，先要对数组进行

​        排序，排序成[0 3 3]的时候再做后面的，也就是说涉及到剪枝的时候需要先对数组进行排序。

4-----**组合总和问题**：当sum==target的时候，将当前的path加到结果中，注意这里[2，2，3]的时候，有了[2 3]那[3 2]这种情况就不用出

​        现了，所以每次i的下一次递归起始位置都是i，当遍历到3的时候，下一次只能从3开始，并且也涉及了剪枝，当前值+sum>target

​        的时候，说明就算进去递归也是不符合情况的，那就直接剪掉，剪枝的前提是对数组进行排序。



### ==整数问题==

1------**链表的两数相加**：注意链表的头结点就是每个值得末尾，所以可以直接根据相对位置得节点进行相加，注意进位carry要保留住，

​          循环判断条件是while(l1!=null && l2!=null) ,注意进位数字和当前相对位置得和num,carry计算方式，当循环结束得时候别忘记carry

​          可能不是0的情况，那就将carry加上

2------**数字相加**：但是链表的头结点是数字的高位，所以这个题可以先将链表烦转，然后计算出来的结果再次反转，涉及到了链表反转的

​         算法。

3------**数字反转**：规定这个数字只能是32位的，也就是说不能使用long来存储，int的最大值为2^31-1，^最小值为-2^31，有符号的

​          123反转后为321，那么-123反转后-321，120反转后12，注意可能反转之前没有超32为，但是反转后就超了，所以要一直判断。

​          **32位的int最大值为2147483647，最小值为-2147483648**，2^31-1,^因为虽然有32位，但是有一位是符号位，所以是2^31。

​          负数的求余取模运算：-2%10=-2，-2/10=0；

​          123：反转的话将每个末尾的值拿出来，然后先判断之前的res是否大于Integer.MAX_VALUE/10,或者小于-Integer.MAX_VALUE/10

​          如果是的话直接返回0，如果不是那就判断之前res是否等于Integer.MAX_VALUE/10，再判断当前的余数是都大于7，小于-8

​          是的话也返回0，说明反转后就会越界，那就不能让其反转，如果都不会出现越界的情况，再把这个末尾的值加在之前的res后面。

4------**快乐数**：每个数字的下一次取值是当前数字每位的平方和，判断最后的取值是不是1，如果是的话就是快乐数，这里需要判断

​          最终的结果就是两种可能，要么是出现了循环，一直在这个范围内循环着，那就不可能是快乐数，要么就是最终到达了1的结果。

​          类似于判断链表是否出现了环形，使用哈希集合来存储每个节点，如果发现加不进去集合了，说明有循环，直接返回false。

### ==二叉树问题==

1-----翻转二叉树
