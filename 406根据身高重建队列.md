# 思路

## 先排序后插入：

```java
//将身高按照降序排序，然后根据kj即前面有多少人比其高，将其插入到对应位置；
//原数组[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]
//按照身高降序,Kj升序排序：[7,0],[7,1],[6,1],[5,0],[5,2],[4,4]
//按照Kj的值插入到对应的res的位置上：
//[7,0]
//[7,0],[7,1]
//[7,0],[6,1],[7,1]
//[5,0],[7,0],[6,1],[7,1]
//[5,0],[7,0],[5,2],[6,1],[7,1]
//[5,0],[7,0],[5,2],[6,1],[4,4][7,1]
//将值放入链表需要o^(2)的复杂度，排序的时间o(nlogn)
//需要o(n^2)的时间才能将值插入到链表中，因为需要遍历链表，然后c
//空间o(logn),排序时候占用了这个大小的空间
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        //先排序，根据身高降序，升高相等时后面的值进行升序排序
        //Arrays.sort默认是升序的o1[1]-o2[1]，
        //降序的话反过来写即可o2[0]-o1[0]
       Arrays.sort(people,(o1,o2)->o1[0]==o2[0]?o1[1]-o2[1]:o2[0]-o1[0]);
       //将排好序的数组插入到res中；
       List<int[]> res=new ArrayList<>();
       for(int[] p:people){
           res.add(p[1],p);//将p插入到P[1]的位置；
       }
       return res.toArray(new int[res.size()][2]);
    }
}
```

ArrayList的add方法源码：一维链表的add方法；

add方法后面可以直接加<>泛型对应的数据，也可以加索引值与对应的值

![image-20220213130342834](C:\Users\28635\AppData\Roaming\Typora\typora-user-images\image-20220213130342834.png)
